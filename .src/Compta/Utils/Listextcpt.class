' Gambas class file

Create Static

Property Read resext As Result

Public Ecart As Float

Private $resext As Result
Private $dtei As LDate
Private $dtes As LDate
Private $scpt As String
Private $jouran As String
Private $req As String

Public Struct borne
  nomfich As String
  dteinf As LDate
  dtesup As LDate
End Struct

Private $brn As Borne[]

Const champ As String = " montantd,montantc,CAST(dte AS DATE) AS dte,compte,libelle,intitule,numero,jour,numdoc,tresorerie,lettree,cloturee,dateech,collectif,numlot,relance,lind "

Public Sub _call(Optional cpt As String, Optional dtei As String = LDate(DateAdd(Now, gb.Year, -8)).L, Optional dtes As String = LDate(DateAdd(Now, gb.Year, 8)).L, Optional ltr As String = "n", Optional stri As String = " dte", Optional origin As String, Optional dteech As String) As Listextcpt

  Dim lst As Listextcpt
  
  lst = New Listextcpt(cpt, dtei, dtes, ltr, stri, origin, dteech)
  Return lst

End

Public Sub _new(Optional cpt As String, Optional dtei As String = LDate(DateAdd(Now, gb.Year, -8)).L, Optional dtes As String = LDate(DateAdd(Now, gb.Year, 8)).L, Optional ltr As String = "n", Optional stri As String = " dte", Optional origin As String, Optional dteech As String)

  Dim res, resf, res1 As Result
  Dim i, prms, der As Integer
  Dim si As String
  Dim req, lett, cli As String
  Dim brn1 As Borne
  Dim dte As LDate
  Dim ok As Boolean = True
  
'  If Not cpt Then Return
  $scpt = cpt
  $dtei = New LDate(dtei)
  $dtes = New LDate(dtes)
  res = Utils.db.Exec("SELECT * FROM Fiches_Parametres")
  If res.Available Then
    $brn = New Borne[]
    $jouran = res!jdr
      Select Case ltr
       Case "o"
          lett = Utils.db.Subst(" AND lettree=&1", True)
        Case "n"
          lett = Utils.db.Subst(" AND lettree=&1 ", False, $jouran)
        Case "t"
          lett = ""
      End Select
    'on recupere les les fichiers mvt et leurs date d'exercice
    For i = 5 To 0 Step -1
      si = Str(i)
      If i = 0 Then si = ""
      resf = Utils.db.Exec("SELECT * FROM Fiches_Mvt" & si & " LIMIT 1")
      If resf.Available Or i = 0 Then
        brn1 = New Borne
        brn1.nomfich = "Fiches_Mvt" & si
        brn1.dtesup = New LDate(res["dteclec" & si])
        brn1.dteinf = New LDate(DateAdd(DateAdd(brn1.dtesup.g, gb.Month, -12), gb.day, 1))
        $brn.Add(brn1)
      Endif
    Next
    'on recupere les bornes du 1° au dernier exercie demandé
    If $dtei.Avant($brn[0].dteinf, True) Then $dtei = $brn[0].dteinf
    der = $brn.Max
    For i = $brn.Max To 0 Step -1
      If $dtei.Apres($brn[i].dteinf) And $dtei.Avant($brn[i].dtesup) Then
        prms = i
      Endif
      If $dtes.Apres($brn[i].dteinf) And $dtes.Avant($brn[i].dteinf) Then
        der = i
      Endif
    Next
    If Not cpt Then Return
    $dtei.L = dtei
    'creation de la requete
    If origin = "relance" Then
      cli = " compte LIKE &3 AND collectif is null AND (" & Utils.db.Subst("dateech <= &1 Or dte<=&1", dteech) & " OR dateech is null) "
    Else
      cli = " compte=&3 "
    Endif
    For i = prms To der
      If ok Then
        If ($dtei.Apres($brn[i].dteinf) And $dtei.Avant($brn[i].dtesup)) Or (i = der And $dtei.Apres($brn[i].dtesup)) And ltr = "t" Then
          ok = False
          'calcul du report a nouveau si nécessaire
          dte = New LDate(DateAdd($dtei.G, gb.Day, -1))
          If i = der Then
             res1 = Utils.db.Exec("SELECT * FROM " & $brn[i].nomfich & " WHERE dte <= &1 AND compte=&2 AND provisoire=False LIMIT 1", dte.D, cpt) 
          Else
            res1 = Utils.db.Exec("SELECT * FROM " & $brn[i].nomfich & " WHERE dte BETWEEN &1 AND &2 AND compte=&3 AND provisoire=False  LIMIT 1", $brn[i].dteinf.D, dte.D, cpt)
          Endif 
          If res1.Available Then
            req = Utils.db.Subst(" UNION SELECT SUM(montantd) AS montantd,SUM(montantc) AS montantc,CAST(&1 AS DATE) AS dte,compte,'Report a nouveau' AS libelle,0 as numero,' ' AS intitule,'  ' as jour,' ' AS numdoc, ' ' AS tresorerie,' ' as lettree, 'T' AS cloturee,' ' AS dateech,' ' AS collectif,' ' AS numlot,' ' AS relance,' ' AS lind FROM " & $brn[i].nomfich & " WHERE dte <= &3 AND compte=&4 AND provisoire=False ", DateAdd($dtei.G, gb.Day, -1), $brn[i].dteinf.D, dte.D, cpt)
            dte = dtsup(i)
            req = Utils.db.Subst("SELECT" & champ & " FROM " & $brn[i].nomfich & " WHERE dte BETWEEN &1 AND &2 AND provisoire=False  AND " & cli & lett, $dtei.D, dte.D, cpt) & req
          Else
            'sans calcul du report a nouveau
             ok = False
            dte = dtsup(i)
            req &= Utils.db.Subst("SELECT" & champ & "FROM " & $brn[i].nomfich & " WHERE dte BETWEEN &1 AND &2 AND provisoire=False  AND " & cli & lett, $dtei.D, dte.D, cpt)
          Endif
        Else
          'requete sur année complete
          If $dtei = $brn[i].dteinf Or ltr <> "t" Then
           ok = False
          dte = dtsup(i)
          req = Utils.db.Subst("SELECT " & champ & " FROM " & $brn[i].nomfich & " WHERE dte BETWEEN &1 AND &2 AND provisoire=False  AND" & cli & lett, $dtei.D, dte.D, cpt)
          Endif
        Endif
      Else
        'requete sur année suivante
        dte = dtsup(i)
        req &= Utils.db.Subst(" UNION (SELECT" & champ & " FROM " & $brn[i].nomfich & " WHERE dte BETWEEN &1 AND &2 AND provisoire=False  AND " & cli & lett & "  AND jour<>&4)", $dtei.D, dte.D, cpt, $jouran)
      Endif
    Next
    req &= " ORDER BY " & stri
    $req = req
  Endif
  
End

Private Function dtsup(ind As Integer) As LDate
  
  If $dtes.Apres($brn[ind].dtesup) Then
    If ind = $brn.Max Then
      Return $dtes
    Endif
    Return $brn[ind].dtesup
  Else
    Return $dtes
  Endif
  
End

Public Function litleres(num As String) As Result     ''Renvoit une écriture par rapport à son numéro et sa date (recherche dans Mvt ... Mvt5)
  
  Dim res As Result
  Dim i As Integer
  
  i = cherche(num, "numero")
  If i > -1 Then
    res = Utils.db.Exec("SELECT * FROM " & $brn[i].nomfich & " WHERE numero=&1 AND provisoire=False ", num)
    Return res
  Endif
  
End

Private Function cherche(num As Variant, chp As String) As Integer

  Dim ok As Boolean
  Dim i As Integer
  Dim dtes As LDate
  
  $resext.MoveFirst
  Repeat
    If num = $resext[chp] Then
      ok = True 
      Break
    Endif
  Until $resext.MoveNext()
  If ok Then
    ok = False
   For i = 0 To $brn.Max
     dtes = dtsup(i)
     If Format($resext!dte, "yyyymmdd") >= Format($brn[i].dteinf.G, "yyyymmdd") And Format($resext!dte, "yyyymmdd") <= Format(dtes.G, "yyyymmdd") Then
       ok = True
       Break
     Endif
   Next
  Endif
  If ok Then Return i Else Return -1
End

Public Sub letcpt(lind As Variant, value As Boolean, numlot As String, choix As String)     ''Lettrage d'un compte d'écriture par rapport soit à un son numéro de lot soit à lind 
  
  Dim i As Integer
  Dim dtes As Date
  
  If choix = "tresor" Then
    i = cherche(lind, "numero")
    lind = $resext!lind
  Else
    i = cherche(lind, "lind")
  Endif
  If i > -1 Then
    Select Case choix
      Case "numlot", "tresor"
        Utils.db.Exec("UPDATE " & $brn[i].nomfich & " SET numlot = &1 where lind = &2 ", numlot, lind)
      Case "lettrage"
        Utils.db.Exec("UPDATE " & $brn[i].nomfich & " SET numlot = &1, lettree = &2 where lind = &3 ", numlot, value, lind)
    End Select
    
  Endif
End

Public Sub letgroupe(Nlot As String, Nlot2 As String, ltr As Boolean, numcpt As String)   ''Lettrage d'un goupe de compte par rapport à son numéro de lot

  Dim i As Integer
  
  For i = 0 To $brn.Max
    Utils.db.Exec("UPDATE " & $brn[i].nomfich & " SET lettree = &1, numlot = &3 WHERE numlot = &2 AND compte = &4 AND provisoire= False ", ltr, Nlot, Nlot2, numcpt)
  Next

End

Private Function ctrl(numlot As String, Optional numcpt As String) As Result
  
  Dim res As Result
  Dim req As String
  Dim dtes As LDate
  Dim i As Integer
  Dim cpt As String
  
  If numcpt Then cpt = numcpt Else cpt = $scpt
  dtes = dtsup(0)
  req = Utils.db.Subst("SELECT montantd,montantc,CAST(dte AS DATE) AS dte,compte,libelle,numero,jour,numdoc,tresorerie,lettree,cloturee,dateech,collectif,numlot,relance,lind FROM " & $brn[i].nomfich & " WHERE compte = &1 AND numlot = &2 AND provisoire=False AND dte BETWEEN &3 AND &4", cpt, numlot, $brn[i].dteinf.D, dtes.D)
  For i = 1 To $brn.Max
    dtes = dtsup(i)
    req &= Utils.db.Subst(" UNION (SELECT montantd,montantc,CAST(dte AS DATE) AS dte,compte,libelle,numero,jour,numdoc,tresorerie,lettree,cloturee,dateech,collectif,numlot,relance,lind  FROM " & $brn[i].nomfich & " WHERE compte = &1 and numlot = &2 AND provisoire=False AND dte BETWEEN &3 AND &4)", cpt, numlot, $brn[i].dteinf.D, dtes.D)
  Next
  res = Utils.db.Exec(req)
  Return res
  
End

Public Function Controle(numlot As String, Optional numcpt As String) As Integer    ''contrôle si le solde d'une écriture est à 0. Retour : 1= oui 0= non

  Dim LetResult As Result
  Dim TotLd As Float
  Dim TotLc As Float
  Dim TotL As Float

  With Utils
    If Not numcpt Then numcpt = $scpt
    LetResult = ctrl(numlot, numcpt)
    If LetResult.Available Then
      Repeat
        TotLd = TotLd + LetResult!montantd
        TotLc = TotLc + LetResult!montantc
      Until LetResult.MoveNext()
      TotL = Utils.arrondi(TotLd - TotLc, 2)
    Endif
    Ecart = TotL
    If TotL = 0 Then
      Return 1
    Else
      Return 0
    Endif

  End With

End

Public Function rechechelot(numlot As String, Optional numcpt As String = $scpt) As Result      ''Retourne les lignes d'écritures liées à un numéro de lot

  Dim res As Result 
  Dim req As String
  Dim i As Integer
  Dim dte As LDate
  
  dte = dtsup(0)
  req = "SELECT " & champ & "FROM " & $brn[0].nomfich & " WHERE compte=&1 AND numlot=&2 AND provisoire=False " & Utils.db.Subst("AND dte BETWEEN &1 AND &2 ", $brn[0].dteinf.D, dte.D)
  For i = 1 To $brn.Max
    dte = dtsup(i)
    req &= "UNION SELECT " & champ & "FROM " & $brn[i].nomfich & " WHERE compte=&1 AND numlot=&2 AND provisoire=False " & Utils.db.Subst("AND dte BETWEEN &1 AND &2 ", $brn[i].dteinf.D, dte.D)
  Next
  
  res = Utils.db.Exec(req, numcpt, numlot)
  Return res

End

Public Function rechedoc(numdoc As String, Optional egal As String = " = ") As Result      ''Retourne les lignes d'écritures liées à un numéro de document

  Dim res As Result 
  Dim req As String
  Dim i As Integer
  Dim dte As LDate
  
  dte = dtsup(0)
  req = "SELECT " & champ & "FROM " & $brn[0].nomfich & ",Fiches_Comptes  WHERE  numdoc " & egal & " &1 AND compte_cc=compte AND (type_cc='C' OR type_cc='F')  AND provisoire=False " & Utils.db.Subst("AND dte BETWEEN &1 AND &2 ", $brn[0].dteinf.D, dte.D)
  For i = 1 To $brn.Max
    dte = dtsup(i)
    req &= "UNION SELECT " & champ & "FROM " & $brn[i].nomfich & ",Fiches_Comptes  WHERE  numdoc " & egal & " &1 AND compte_cc=compte AND (type_cc='C' OR type_cc='F') AND provisoire=False  " & Utils.db.Subst("AND dte BETWEEN &1 AND &2 ", $brn[i].dteinf.D, dte.D)
  Next
  
  res = Utils.db.Exec(req, numdoc)
  Return res


End

Private Function resext_Read() As Result      ''Retourne le résultat de la requête définie par _new

  $resext = Utils.db.Exec($req) 
  Return $resext

End
