' Gambas class file

Inherits ButtonBox
Export
Create Static

Public Enum commence_par, fini_par, contient

'variables publics
Public dte As New LDate As "dte"
Public lke As Integer = contient      ''Indique à la requete comment doit se comporter le LIKE quand recherche = True
'variables privées
Private $value As Float
Private $text As String
Private $textesc As String
Private $nbdec As String
Private $reg As String
Private $regp As Boolean = False
Private $numerique As Boolean = False
Private $date As Boolean = False
Private $datetime As Boolean = False
Private $regex As New RegExp
Private $win As Window             ''Fenetre pour recherche
Private $grd As GridView          ''Gridview pour la recherche
Private $champ As String[]
Private $fichier As String
Private $rech As Boolean
Private $y As Float
Private $x As Float
Private $objp As Object
Private $cond As String
'constantes prédéfinies
Public Const all As String = ".*"       'tout est autorisé
Public Const path As String = "[a-zA-Z0-9_.+-@:&/]*" 'saisie d'un chemin avec protocol d'acces et credential
Public Const url As String = "[a-zA-Z0-9_.+-@:&!*'();:@=+$,/?#\\[\\]%]*" 'saisie d'une url ... a revoir
Public Const code As String = "[a-zA-Z0-9]*"           'saisie d'un code tel que supporté par Laurux
Public Const compte As String = "[0-9]*"               'saisie d'un compte à la main
Public Const num As String = "-?[0-9]*[,.]?[0-9]*"       'saisie d'un numérique avec ,
Public Const chaine As String = "[^%^_]*"                 'saisie d'une chaine en excluant les caractéres spéciaux de recherche BD (a compléter et vérifier)
Public Const mail As String = "[a-zA-Z0-9_.+-]+@?[a-zA-Z0-9.-]*"     'saisie d'une adresse mail peut certainement s'améliorer
Public Const dts As String = "[0-9]{0,2}[./-]?[0-9]{0,2}[./-]?[0-9]{0,4}"
Public Const dtst As String = "[0-9]{0,2}[./-]?[0-9]{0,2}[./-]?[0-9]{0,4}[ ]?[0-9]{0,2}[:]?[0-9]{0,2}"
Public Const nofilter As String = ".*" 
' a compléter si autre idées par ex : saisie des comptes client ...
'comme les paterns sont parfois un peu difficiles à trouver et à mettre au point il serait peut être bien de les mettres en constantes ?
' il ne faut pas mettre de caractéres obligatoires dans les paterns par ex dans mail @{1} ne fonctionne pas.
'propriétés
Property Value As Float       ''gére la valeur numérique de l'objet
Property numerique As Boolean     ''si cette objet est que numérique
Property Dat As Boolean               ''si cette objet est une date
Property DateTime As Boolean          ''si cette objet est une date avec heure
Property nbdec As String            ''le nombre de décimal que contient cette objet
Property reg As String              ''le regex de cette objet. Il remplace la constante définie ci-dessus
Property MaxLenght As Integer     '' longueur maximum de l'objet
Property Text As String     ''gére la valeur alfa de l'objet
Property recherche As Boolean   ''si on ouvre une fenetre de recherche
Property conteneur As Object    ''on passe le conteneur dans lequel on veut mettre la fenêtre
Property condition As String        ''si on veut rajouter une condition à la requete
Property RechX As Float
Property RechY As Float

Public Sub _new()

  Dim obs As Observer
  
  obs = New Observer(Me) As "butb"
  Me.Picture = Picture["icon:/16/clear"]
  $reg = chaine
  $regex.Compile($reg)
  $textesc = Me.Editor.Text

End

'gestion des évenements
Public Sub butb_click()

  If Me.Enabled = False Or Me.ReadOnly Then Return
 
  If Object.IsValid($grd) And If Last.tag = $grd.Tag Then
    If Last.row = -1 Then Return
    Me.Text = $grd[Last.Row, 0].Text
    Desktop.SendKeys("[Return]")
  Else
    $value = 0
    Me.text = ""
    If $rech Then affgrd()
  Endif
  
End

Public Sub butb_keypress()

  Select Case Key.Code
    Case Key.Esc
      $text = $textesc
      Me.Editor.Text = $textesc
    
    Case Key.F2
      If (Me.Enabled Or Not Me.ReadOnly) Then
        If $datetime
          Me.Editor.Text = LDateC.Select(dte).LT
          $text = Me.Editor.Text
        Else If $date
          Me.Editor.Text = LDateC.Select(dte).L
          $text = Me.Editor.Text
        Endif
      Endif
      
    Case Key.Enter, Key.Return, Key.Tab
      If $rech Then
        If $grd.Rows.Max > -1 Then
          Me.Text = $grd[0, 0].Text
        Endif
        Try $win.Delete
      Endif
      
  End Select

End

Public Sub butb_DblClick()
  
  If (Me.Enabled Or Not Me.ReadOnly) Then
    If $datetime
      Me.Editor.Text = LDateC.Select(dte).LT
      $text = Me.Editor.Text
    Else If $date
      Me.Editor.Text = LDateC.Select(dte).L
      $text = Me.Editor.Text
    Endif
  Endif
  
End

Public Sub butb_change()

  Dim x As Integer
  
  If IsNull(Me.Editor.Text) Then
    $text = ""
    $value = 0
    Return
  Endif
  Try $regex.Exec(Me.Editor.Text)
  If Error Then 
    Me.Editor.Text = $text
    Return
  Endif
  x = Me.Pos
  Me.Editor.Text = $regex.Text
  If Me.Editor.Text Match "." And $numerique Then Me.Editor.Text = Replace(Me.Editor.Text, ".", ",")
  $text = Me.Editor.Text
  If $rech Then affgrd()
  Me.pos = x
  
End

Public Sub butb_gotfocus()

  Dim i As Integer
  
  If $numerique And $value <> 0 Then
    Me.Editor.Text = Str($value)
  Endif
  $text = Me.Editor.Text
  $textesc = Me.Editor.Text
  If Not Object.IsValid($win) And $rech Then
    If Object.IsValid($objp) Then $win = New Window($objp) As "win" Else $win = New Window As "win"
    $win.x = $x
    $win.Y = $y
    $win.Border = False
    $win.Background = Color.Black
    '$win.AutoResize = True
    $grd = New GridView($win) As "butb"
 '   $grd.AutoResize = True
    $grd.Padding = 4
    $grd.Background = Color.White
    $grd.Columns.Count = $champ.Count
    $grd.Width = (Me.Font.Size * $champ.Count * 15) 
    $grd.Height = Me.Font.Size * 15
    For i = 0 To $champ.Max
      $grd.Columns[i].Width = $grd.Width / $champ.Count
    Next
    $grd.Rows.Height = Me.Font.Height + 3
    $win.Height = $grd.Height
    $win.Width = $grd.Width 
    $win.Show
    $win.TopOnly = True
    $grd.x = 0
    $grd.y = 0
    $grd.Mode = Select.Single
    $grd.Tag = 0
    $grd.Show
    affgrd
    Me.SetFocus
  Endif
  
End

Public Sub butb_lostfocus()

  If $numerique Then
    If IsNull(Me.Editor.Text) Or Val($text) = Null Then
      $text = "0"
      Me.Editor.Text = "0"
      $textesc = "0"
      $value = 0
    Else
      $value = Val($text)
      If Not IsNull($nbdec) Then
        $text = Format($value, frm())
        Me.Editor.Text = $text
        $textesc = $text
      Endif
    Endif
  Endif
  If $datetime Then
    If Not IsNull(Me.Editor.Text) Then
      dte.LT = Me.Editor.Text
      Me.Editor.Text = dte.LT
      $text = dte.LT
      $textesc = dte.LT
    Endif
  Else If $date Then
    If Not IsNull(Me.Editor.Text) Then
      dte.L = Me.Editor.Text
      Me.Editor.Text = dte.L
      $text = dte.L
      $textesc = dte.L
    Endif
  Endif
  Try $win.Delete 'TODO confimer le besoin avec patrickmag

End

Public Sub dte_change(dt As LDate)

  If $datetime Then
    Me.Editor.Text = dt.LT
  Else If $date Then
    Me.Editor.Text = dt.L
  Endif

End

Private Function Value_Read() As Float

  If $numerique Then
    Return $value
  Else
    Return 0
  Endif

End
'proprietés
Private Sub Value_Write(Value As Float)

  If $numerique Then
    If IsNull(value) Then $value = 0 Else $value = Value
    If IsNull($nbdec) Then $text = Str($value) Else $text = Format($value, frm())
    Me.Editor.Text = $text
  Endif

End

Private Function Text_Read() As String

  Return Me.Editor.Text

End

Private Sub Text_Write(Value As String)

  If $numerique Then
    If IsNumber(value) Then
      $value = Val(value)
    Else
      $value = 0
    Endif
    If Not IsNull($nbdec) Then $text = Format($value, frm()) Else $text = value
    Me.Editor.Text = $text
    Return
  Endif
  If $datetime Then
    $text = LDate(value).LT
    dte.LT = $text
    Me.Editor.Text = $text
    $value = 0
    Return
  Else If $date Then
    $text = LDate(value).L
    dte.L = $text
    Me.Editor.Text = $text
    $value = 0
    Return
  Endif
  
  Me.Editor.Text = value
  
End

Private Function numerique_Read() As Boolean

  Return $numerique

End

Private Sub numerique_Write(Value As Boolean)

  If $numerique <> Value And Not $regp Then
    If value Then $reg = num Else $reg = chaine
    $regex.Compile($reg)
  Endif
  $numerique = value
  If $numerique Then
    $date = False
    $datetime = False
  Endif
  If $numerique And Val($text) <> Null Then
    $value = Val($text)
    Me.Editor.Text = $text
  Endif

End

Private Function Dat_Read() As Boolean

  Return $date

End

Private Function DateTime_Read() As Boolean

  Return $datetime

End

Private Sub Dat_Write(Value As Boolean)

  If $numerique And value Then $value = 0
  If value Then $numerique = False
  If $date <> value And Not $regp Then
    If value Then $reg = dts Else $reg = chaine
    $regex.Compile($reg)
  Endif
  If $date And $text Then 
    dte.L = $text
    Me.Editor.Text = dte.L
    $text = dte.L
  Endif
  $date = value
  
End

Private Sub DateTime_Write(Value As Boolean)

  If $numerique And value Then $value = 0
  If value Then $numerique = False
  If $datetime <> value And Not $regp Then
    If value Then $reg = dtst Else $reg = chaine
    $regex.Compile($reg)
  Endif
  If $datetime And $text Then 
    dte.LT = $text
    Me.Editor.Text = dte.LT
    $text = dte.LT
  Endif
  $datetime = value
  
End

Private Function nbdec_Read() As String

  Return $nbdec

End

Private Sub nbdec_Write(Value As String)

  $nbdec = value
  If $numerique And Val($text) <> Null Then
    $value = Val($text)
    If IsNull($nbdec) Then $text = Str($value) Else $text = Format($value, frm())
    Me.Editor.Text = $text
  Endif

End


Private Function reg_Read() As String

  Return $reg

End

Private Sub reg_Write(Value As String)

  $reg = value
  $regp = True
  $regex.Compile($reg)

End

Private Function MaxLenght_Read() As Integer

  Return Me.Editor.Value

End

Private Sub MaxLenght_Write(Value As Integer)

  Me.Editor.MaxLength = value

End

Private Function recherche_Read() As Boolean

  Return $rech

End

Private Sub recherche_Write(Value As Boolean)

  $rech = value

End

Private Function RechX_Read() As Float

  Return $x

End

Private Sub RechX_Write(Value As Float)

  $x = value

End

Private Function RechY_Read() As Float

  Return $y

End

Private Sub RechY_Write(Value As Float)

  $y = value

End

Private Function conteneur_Read() As Object

  Return $objp

End

Private Sub conteneur_Write(Value As Object)

  $objp = value

End

Private Function condition_Read() As String

  Return $cond

End

Private Sub condition_Write(Value As String)

  $cond = value

End

Public Sub butb_Mousewheel()

  Me.Editor.SetFocus

End

'fonctions publics
Public Sub Select(Optional start As Integer, length As Integer)
  
  If Start = 0 And length = 0 Then
    Me.Editor.SelectAll
    Return
  Endif
  
  Me.Editor.Select(start, length)
  
End

Public Sub Unselect()

  Me.Editor.Unselect

End

Public Sub champs(fichier As String, ...)   ''Le premier argument est le nom du fichier puis les champs que vous voulez voire dans le gridview. Le 1° champ sera celui retourné

  Dim ch As String
  
  $fichier = fichier
  $champ = Param.All

End

'fonctions privées
Private Function frm() As String
  
  Dim i As Integer
  Dim ch As String
  
  If Val($nbdec) = 0 Then Return "0"
  ch = "0."
  For i = 1 To Val($nbdec)
    ch &= "0"
  Next
  Return ch
End

Private Sub affgrd()
  
  Dim res As Result
  Dim i As Integer
  Dim value As String
  
  If Not Object.IsValid($win) Then Return
  Select Case lke
    
    Case commence_par
      value = $text & "%"
    Case fini_par 
      value = "%" & $text
    Case contient
      value = "%" & $text & "%"
      
  End Select
  res = Utils.db.Exec("SELECT " & $champ.Join() & " FROM " & $fichier & " WHERE " & $champ[0] & " LIKE &1 " & $cond, value)
  If res.Available Then
    $grd.Rows.Count = res.Count
    Repeat 
      For i = 0 To $champ.Max
        $grd[res.Index, i].Text = res[$champ[i]]
      Next
    Until res.MoveNext()
  Else
    $grd.Rows.Count = 0
    $grd.Clear
  Endif
  Me.SetFocus
  
End

